/*
 * spi.c
 *
 *  Created on: 11 de out de 2016
 *      Author: elder
 */

uint8_t spi_init()
{
    volatile uint8_t ucReturnValue;

    //Set P1.1 for slave reset
    GPIO_setOutputHighOnPin(
        GPIO_PORT_P1,
        GPIO_PIN1
        );

    //Set P1.1 for slave reset
    GPIO_setAsOutputPin(
        GPIO_PORT_P1,
        GPIO_PIN1
        );

    //P3.5,4,0 option select
    GPIO_setAsPeripheralModuleFunctionInputPin(
        GPIO_PORT_P3,
        GPIO_PIN5 + GPIO_PIN4 + GPIO_PIN0
        );

    //Initialize Master

    USCI_A_SPI_initMasterParam param = {0};
    param.selectClockSource = USCI_A_SPI_CLOCKSOURCE_SMCLK;
    param.clockSourceFrequency = UCS_getSMCLK();
    param.desiredSpiClock = 500000;
    param.msbFirst = USCI_A_SPI_MSB_FIRST;
    param.clockPhase = USCI_A_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT;
    param.clockPolarity = USCI_A_SPI_CLOCKPOLARITY_INACTIVITY_HIGH;

    ucReturnValue = USCI_A_SPI_initMaster(USCI_A0_BASE, &param);

    if(STATUS_FAIL == ucReturnValue)
    {
        return ucReturnValue;
    }

    //Enable SPI module
    USCI_A_SPI_enable(USCI_A0_BASE);

    //Enable Receive interrupt
    USCI_A_SPI_clearInterrupt(USCI_A0_BASE,
                              USCI_A_SPI_RECEIVE_INTERRUPT);
    //USCI_A_SPI_enableInterrupt(USCI_A0_BASE,  USCI_A_SPI_RECEIVE_INTERRUPT);

    //Now with SPI signals initialized, reset slave
    GPIO_setOutputLowOnPin(
        GPIO_PORT_P1,
        GPIO_PIN1
        );


    //Wait for slave to initialize
    __delay_cycles(100);

    return ucReturnValue;

}

void spi_is_busy()
{
    //USCI_A0 TX buffer ready?
    return USCI_A_SPI_isBusy(USCI_A0_BASE);
}

void spi_send_byte(uint8_t ucTransmitData, int ch)
{
    //Transmit Data to slave
    if(ch == 0)
        USCI_A_SPI_transmitData(USCI_A0_BASE, transmitData);
    if(ch == 1)
        USCI_A_SPI_transmitData(USCI_A1_BASE, transmitData);

}

void spi_send(uint8_t *transmitData, uint8_t bytes)
{
    while(bytes-- > 0)
    {
        spi_send_byte(transmitData++)
    }
}

uint8_t spi_receive_byte()
{
    return USCI_A_SPI_receiveData(USCI_A0_BASE);
}

void spi_receive(uint8_t *receiveData, uint8_t bytes)
{
    volatile uint8_t cont = 0;
    while(cont < bytes)
    {
        receiveData[cont++] = spi_receive_byte();
    }
}
